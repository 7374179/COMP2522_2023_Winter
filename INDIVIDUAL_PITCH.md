# Individual Pitch


### Yeju Jung (Barrier, BarrierManager, and BarrierTest class)
As the developer in charge of the Barrier and BarrierManager classes, my responsibilities include managing the barriers that protect the player's spaceship from the aliens' bullets, creating and managing the barriers in the game, including positioning, destruction, and regeneration. Also I will write the test to see if Barrier works fine.

### Taehyuk Chung (Missile, and  MissileManager, and MissileTest class)
As the missile developer, my role includes designing and implementing the missile object, creating collision detection, refining mechanics, collaborating with the team, and debugging.

### Bingdi Zhou (Invader class, Invader Manager class, Sprite, and InvaderTest class)
As a developer of the Invader class and Invader Manager class, I will implement the Invader class which will represent individual invaders in the game and the InvaderManager class which will manage the collection of invaders and provide methods for adding, removing, and updating their properties. I will also have a InvaderTest class to test  the Invader class after its implementation.

### Tae Hyung Lee (Player, PlayerManager,SpriteManager, and PlayerTest class)
As the designated sprite artist and player manager for the Java project, I will create an engaging and visually appealing representation of the player while ensuring that the game mechanics are functioning smoothly through rigorous testing and debugging. By utilizing my expertise in both art and programming, I aim to deliver a seamless gaming experience for all players.

### All 4 team-members tasks (Windows, Interfaces: Shootable, Movable, Collidable)
Our game requires objects that can be shot, moved, and collided with, so we propose implementing three Java interfaces: Shootable, Movable, and Collidable.
The Shootable interface will represent objects that can be shot, the Movable interface will represent objects that can move, and the Collidable interface will represent objects that can collide with other objects.
Implementing these interfaces will allow for more modular and reusable code in our game, and make it easier to add new objects with these behaviors.



